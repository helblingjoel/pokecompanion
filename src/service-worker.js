import { build, files, version } from '$service-worker';

// https://github.com/microsoft/TypeScript/issues/11781 - this is needed for TS and ESLint

/// env serviceworker
const globalThis = /** @type {unknown} */ (self);
/// <reference no-default-lib="true"/>
/// <reference lib="es2020" />
/// <reference lib="WebWorker" />
const sw = /** @type {ServiceWorkerGlobalScope & typeof globalThis} */ (globalThis);

const ASSETS = `assets-${version}`;
const REQUESTS = `requests-${version}`;

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = build.concat(files);

/** @param {ExtendableEvent} event */
function install_listener(event) {
	event.waitUntil(
		caches
			.open(ASSETS)
			.then((cache) => {
				cache.addAll(to_cache);
			})
			.catch((err) => {
				console.error(err);
			})
			.then(() => {
				sw.skipWaiting();
			})
			.catch((err) => {
				console.error(err);
			})
	);
	console.log(`Service worker initialised`);
}

/** @param {ExtendableEvent} event */
function activate_listener(event) {
	event.waitUntil(
		caches.keys().then(async (keys) => {
			// delete old caches
			for (const key of keys) {
				if (key !== ASSETS) await caches.delete(key);
			}

			sw.clients.claim();
		})
	);
}

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 * @param {RequestInfo} request
 * @param {string} cacheName
 */
async function networkFirst(request, cacheName = REQUESTS) {
	console.log('network first for', request);
	const cache = await caches.open(cacheName);

	try {
		if (!navigator.onLine) {
			return new Response('You are offline', {
				status: 523,
				statusText: 'Requested an online resource while offline'
			});
		}

		const response = await fetch(request);

		if (response.status < 400) {
			cache.put(request, response.clone());
		}

		return response;
	} catch (err) {
		const cachedResponse = await cache.match(request);

		if (cachedResponse) {
			return cachedResponse;
		}

		if (!navigator.onLine) {
			return new Response('You are offline', {
				status: 523,
				statusText: 'Requested an online resource while offline'
			});
		}
	}
}

/**
 * Try to load an object from cache first, fall back to the network and cache it then
 * @param {RequestInfo} request
 */
async function cacheFirst(request, cacheName = REQUESTS) {
	console.log('cache first for', request);
	const cache = await caches.open(cacheName);
	const cachedResponse = await cache.match(request);

	if (cachedResponse) {
		return cachedResponse;
	}

	if (!navigator.onLine) {
		return new Response({
			status: 523,
			statusText: 'Requested an online resource while offline'
		});
	}

	const networkResponse = await fetch(request);
	if (networkResponse.status < 400) {
		cache.put(request, networkResponse.clone());
	}
	return networkResponse;
}

async function networkOnly(request) {
	if (!navigator.onLine) {
		return new Response({
			status: 523,
			statusText: 'Requested an online resource while offline'
		});
	}

	return await fetch(request);
}

const cacheFirstHosts = ['pokeapi.co', self.location.hostname];
/** @param {FetchEvent} event */
async function fetch_listener(event) {
	const request = event.request;
	const url = new URL(request.url);

	if (event.request.method !== 'GET') {
		event.respondWith(networkOnly(request));
		return;
	}

	// Check if the request's host is in the cacheFirstHosts array
	if (cacheFirstHosts.includes(url.hostname)) {
		if (url.hostname === self.location.hostname) {
			event.respondWith(cacheFirst(request, ASSETS));
			return;
		}
		event.respondWith(cacheFirst(request, REQUESTS));
		return;
	}

	event.respondWith(networkFirst(request, REQUESTS));
}

sw.addEventListener('install', install_listener);
sw.addEventListener('activate', activate_listener);
sw.addEventListener('fetch', fetch_listener);
